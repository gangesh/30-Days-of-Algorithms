# 30-Days-of-Algorithms
Studying one algorithm per day for 30 days to strengthen my programming skills.

## Background
I got my university degree in graphic design. I didn't start coding until I was 28. I do not have a background in computer science, and I've always felt self-conscious about that. Until recently, it had never directly impacted my career. 

I recently did not make it past a first-round coding challenge because my code was "too complex". I went online to see if I could find evidence to prove the reviewer wrong. What I discovered very quickly is, "SHE WAS RIGHT".  I was really hurt and disappointed in myself, but I am not one to navel-gaze for long. I decided to see it as a challenge and learning experience. 

To strengthen my understanding of the most common and most useful algorithms, I decided to pick one algorithm every day for 30 days and learn how to use it effectively and to commit it to memory. 

Life being what it is - which is to say unpredictable and hectic - I may not post an alogirthm every single day, but I will post one "for" every day. For instance, today I am posting the first 3 days. Some days I may not have time to post one but I will make up for any missed days.

I will not only add each algorithm here but will post each one as a public gist. feel free to join the discussion on the gists.

## The Algoritms

#### [Day 01 - Euclid's Algorithm](src/01-euclids-gcd-algorithm.js) - ([gist](https://gist.github.com/iconifyit/580d4ae1c9851bd91b3559ec848f56b0)) 
   
Euclid's Algorithm for finding the greatest common divisor of two positive integers.
   
#### [Day 02 - Find Missing Number 1 ... N](src/02-find-missing-number-1-to-n.js) - ([gist](https://gist.github.com/iconifyit/6d43593d38723fcca48b6f1807c54022))
    
Algorithm to find the missing number given an array of positive integers from 1 - N, with no duplicates and only one missing number.

#### [Day 03 - Bubble Sort](src/03-bubble-sort.js) - ([gist](https://gist.github.com/iconifyit/25d0911af55e582f9a84fc63ee871dac))

Bubble sort has a worst-case and average complexity of О(n2), where n is the number of items being sorted. Even though it is not the most efficient algorithm, it is worth knowing how to do.

#### [Day 04 - List Intersection](src/04-find-shared-items.js) - ([gist](https://gist.github.com/iconifyit/7148719444a2c3ad0616feeed2382aad))

Efficient algorithm to find the intersection of two lists. This is a common coding test problem but also a common problem to encounter in real-world apps.

#### [Day 05 - Array to Tree](src/05-array-to-tree.js) - ([gist](https://gist.github.com/iconifyit/7be16df21fe9fd6853b2aabdd976214a))

This is a very elegant solution by [Philip Stanislaus](https://github.com/philipstanislaus) that converts a flat array into a tree in O(n) time. It works in a single pass. Look, ma. No Recursion !!! :-)

#### [Day 06 - Merge Sort](src/06-merge-sort.js) - ([gist](https://gist.github.com/iconifyit/99832a8e8efdf22858bba6773eefd7ec))

Although it is not the most efficient sorting algorithm, Merge Sort is good to know and is fairly easy to implement.

#### [Day 07 - Quick Sort](src/07-quick-sort.js) - ([gist](https://gist.github.com/iconifyit/02ecccc73f00548389b7812f2bae2d23))

Quicksort is one of the most efficient sorting algorithm with O(log n) Big-O notation. It can be 2x - 3x faster than merge sort. This article by [César Antón Dorantes](https://medium.com/cesars-tech-insights/quicksort-17c5d24e7e5f) does a great job explaining how it works.